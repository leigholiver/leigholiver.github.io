<!doctype html><html lang=en-gb><head><meta charset=utf-8><meta name=viewport content="width=device-width"><title>Tips for `supervisord` configuration | Leigh Oliver</title><script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-180824262-1','auto'),ga('send','pageview')</script><script async src=https://www.google-analytics.com/analytics.js></script><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bulma@0.9.2/css/bulma.min.css><link rel=stylesheet href=/css/styles.css><meta property="og:title" content="Tips for `supervisord` configuration"><meta name=description content="Page description"><meta property="og:description" content="Page description"><meta property="og:locale" content="en_GB"><meta property="og:type" content="website"><meta property="og:url" content="https://leigholiver.com/posts/tips-for-supervisord-config/"><link rel=canonical href=https://leigholiver.com/posts/tips-for-supervisord-config/><link rel=icon href=/favicon.ico><link rel=icon href=/favicon.svg type=image/svg+xml></head><body><section class="section site-container"><div class=container><div class=columns><div class="column is-one-quarter is-hidden-mobile site-sidebar"><div class=sidebar-spacer></div><div class=sidebar-image><img src=/images/profile.jpeg><div class=sidebar-image-credit>Photo: Bethany Lock</div></div><div class="has-text-centered sidebar-text"><div class=header>Leigh Oliver</div><div class=caption>Cloud/DevOps/Software engineer</div><div class=socials><a href=https://twitter.com/leigholiver_ target=_blank rel=noopener><i class="fab fa-twitter-square"></i></a><a href=https://www.linkedin.com/in/leigh-oliver-32ab63187/ target=_blank rel=noopener><i class="fab fa-linkedin"></i></a><a href=https://github.com/leigholiver target=_blank rel=noopener><i class="fab fa-github-square"></i></a></div></div></div><div class="column is-three-quarters"><nav class=navbar role=navigation aria-label="main navigation"><div class=navbar-brand><h1>Tips for `supervisord` configuration</h1><a role=button class=navbar-burger aria-label=menu aria-expanded=false data-target=navBar><span aria-hidden=true></span><span aria-hidden=true></span><span aria-hidden=true></span></a></div><div id=navBar class=navbar-menu><div class=navbar-start></div><div class=navbar-end><a class=navbar-item href=/>Home</a>
<a class=navbar-item href=/posts/>Posts</a>
<a class=navbar-item href=/tags/>Tags</a></div></div></nav><br><section class=section><div class=columns><div class=column><span class="tag is-link is-light"><a href=https://leigholiver.com/tags/technical>technical</a></span>
<span class="tag is-link is-light"><a href=https://leigholiver.com/tags/quick-tips>quick-tips</a></span>
<span class="tag is-link is-light"><a href=https://leigholiver.com/tags/containers>containers</a></span>
<span class="tag is-link is-light"><a href=https://leigholiver.com/tags/supervisor>supervisor</a></span></div><div class="column has-text-right">Mar 22, 2022</div></div><div class=content><p><a href=http://supervisord.org/><code>supervisord</code></a> is a really useful tool for managing processes in containers, but I find it&rsquo;s configuration a bit lacking.
There are some sensible defaults missing, no way to dynamically configure which processes should be running on a container, and I&rsquo;m often left with duplicated configuration.
Having spent some time working with it I&rsquo;d like to share my approach and solution to these headaches.</p><p>One of the first hurdles I ran into when working with supervisor was trying to dynamically configure which processes should run.
Imagine this - we have a web application which offloads tasks to a background queue for later processing.
This background queue is consumed by a worker container which shares the same code and environment as the web application, but runs a different command to work on jobs from the queue.</p><p>Initially when trying to implement this architecture I tried running a second instance of the container with an overridden Docker <code>COMMAND</code>.
This was better than maintaining two images, but had the immediate drawback of losing all of the advantages of supervisor for the queue worker.
This also moved the responsibility of the command to run for a queue worker outside of the application boundary - going from being defined within the image to defined by some program running the container.</p><p>If is of course possible to set up multiple supervisor config files and choose between them dynamically, but this leads to a lot of duplication which just doesn&rsquo;t sit well with me.
My dream was to be able to define &ldquo;roles&rdquo; - a group of processes to run which can be supplied as config files and chosen between at runtime.
For example, a Python application might define a &ldquo;web&rdquo; role running a uWSGI web server and a &ldquo;worker&rdquo; role running celery to process jobs in the background.
By setting the <code>ROLES</code> environment variable to <code>web</code> or <code>worker</code> (or even <code>web,worker</code>), the relevant processes would be added to the configuration when the container starts up.</p><p>As with most of my problems, my answer was to write a bash script.
I split out my configuration file into a suitable directory structure:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>- /etc/supervisor/
  - supervisor.conf    <span style=color:#75715e># Main supervisord configuration file</span>
  - roles/             <span style=color:#75715e># A directory of process groups to choose from</span>
    - web.conf         <span style=color:#75715e># Supervisord configuration for &#34;web&#34; containers</span>
    - worker.conf      <span style=color:#75715e># Supervisord configuration for &#34;worker&#34; containers</span>
</code></pre></div><p>I then wrote a script which reads the <code>ROLES</code> environment variable, and adds matching configuration file(s) from the <code>roles/</code> directory to the supervisor configuration:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e>#!/bin/sh
</span><span style=color:#75715e></span>
<span style=color:#75715e># split the comma seperated list into a newline seperated list which we can iterate over</span>
ROLES<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>echo <span style=color:#e6db74>&#34;</span>$ROLES<span style=color:#e6db74>&#34;</span> | tr <span style=color:#e6db74>&#34;,&#34;</span> <span style=color:#e6db74>&#34;\n&#34;</span><span style=color:#66d9ef>)</span>

<span style=color:#75715e># for each role specified, append the config to the main config file</span>
<span style=color:#66d9ef>for</span> ROLE in $ROLES; <span style=color:#66d9ef>do</span>
    cat /etc/supervisor/roles/$ROLE.conf &gt;&gt; /etc/supervisor/supervisor.conf
<span style=color:#66d9ef>done</span>

<span style=color:#75715e># start supervisor and the processes</span>
supervisord -c /etc/supervisor/supervisor.conf
</code></pre></div><p>This feels much tidier and gives a developer a lot of flexibity to run the same image in multiple configurations.
In development both the web and worker roles can run on a single container, whilst in a production environment the roles can run in seperate services which can be managed and scaled independently - with all of the benefits of supervisor.</p><p>Having proven the concept I quickly found ways to iterate and improve the script.
I was duplicating the same 4 lines of configuration in every process to send log output to <code>stdout</code>, the preferred destination for container logs.
I moved these lines into a <code>common.conf</code> file, and updated the script to append this file to the configuration after adding each role.</p><p>I also noticed whilst testing this setup that if I had configured supervisor to give up when a process couldn&rsquo;t start, the container wouldn&rsquo;t exit.
The remaining processes would continue to run, or supervisor would sit idle if everything had failed.</p><p>Supervisor can be configured with <a href=http://supervisord.org/events.html>event listeners</a> - programs which run according to certain supervisor events.
One such event is the <code>PROCESS_STATE_FATAL</code> event, which is triggered in this scenario when a process cannot start and is in the <code>FATAL</code> state.</p><p>Event listeners are usually written to respond to specific events, but in this case I found it sufficient use a bash one-liner which waits for this event and asks supervisor to quit if it gets it:</p><pre><code class=language-conf data-lang=conf>[eventlistener:exit-on-fatal]
events=PROCESS_STATE_FATAL
command=sh -c &quot;printf 'READY\n' &amp;&amp; while read line; do kill -SIGQUIT $PPID; done &lt; /dev/stdin&quot;
</code></pre><p>I&rsquo;ve posted an expanded version of this configuration <a href=github.com/leigholiver/supervisord-config>on my GitHub</a>, which can be easily customised and used in your images if you find this helpful.</p></div></section></div></div></div></section><script src=/js/nav.js></script></body></html>